"use client";
import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/lib/supabase';
import { useAuth } from '@/hooks/use-auth';
import { useToast } from '@/hooks/use-toast';
import { useMaterials } from '@/hooks/use-materials';
import { useProducts } from '@/hooks/use-products';
import type {
  SimpleExpense,
  CreateSimpleExpenseData,
  FixedCostTemplate,
  SupplierSuggestion,
  ExpenseStats
} from '@/types/simple-expense';
import { SimpleExpenseCategory } from '@/types/simple-expense';
import { MaterialRequest } from '@/types/material-request';

export function useSimpleExpenses() {
  const [expenses, setExpenses] = useState<SimpleExpense[]>([]);
  const [loading, setLoading] = useState(false);
  const [supplierSuggestions, setSupplierSuggestions] = useState<SupplierSuggestion[]>([]);
  const { user } = useAuth();
  const { toast } = useToast();
  const { updateStock: updateMaterialStock } = useMaterials();
  const { updateStock: updateProductStock } = useProducts();

  const mapRowToExpense = (row: any): SimpleExpense => ({
    id: row.id,
    date: row.expense_date,
    amount: Number(row.amount),
    category: row.category,
    subCategory: row.sub_category,
    description: row.description,
    supplier: row.supplier,
    quantity: row.quantity,
    unitPrice: Number(row.unit_price),
    branchId: row.branch_id,
    branchName: row.branch_name,
    paymentMethod: row.payment_method,
    receiptUrl: row.receipt_url,
    receiptFileName: row.receipt_file_name,
    inventoryUpdates: row.inventory_updates || [],
    relatedRequestId: row.related_request_id,
    relatedOrderId: row.related_order_id,
    isAutoGenerated: row.is_auto_generated,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  });

  const fetchExpenses = useCallback(async (filters?: {
    branchId?: string;
    category?: SimpleExpenseCategory;
    dateFrom?: Date;
    dateTo?: Date;
    limit?: number;
    offset?: number;
  }) => {
    if (!user) return;
    if (!filters?.offset) setLoading(true);

    try {
      let query = supabase.from('simple_expenses').select('*');
      if (filters?.branchId) query = query.eq('branch_id', filters.branchId);
      if (filters?.category) query = query.eq('category', filters.category);
      if (filters?.dateFrom) query = query.gte('expense_date', filters.dateFrom.toISOString());
      if (filters?.dateTo) query = query.lte('expense_date', filters.dateTo.toISOString());

      const limit = filters?.limit || 3000;
      const offset = filters?.offset || 0;

      const { data, error } = await query
        .order('expense_date', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;
      const expenseList = (data || []).map(mapRowToExpense);

      if (offset > 0) {
        setExpenses(prev => [...prev, ...expenseList]);
      } else {
        setExpenses(expenseList);
      }

      return { expenses: expenseList, hasMore: expenseList.length >= limit };
    } catch (error) {
      console.error(error);
      toast({ variant: "destructive", title: "오류", description: "지출 목록 로드 실패" });
      return { expenses: [], hasMore: false };
    } finally {
      setLoading(false);
    }
  }, [user, toast]);

  const addExpense = useCallback(async (data: CreateSimpleExpenseData, branchId: string, branchName: string): Promise<boolean> => {
    if (!user) return false;
    setLoading(true);
    try {
      let receiptUrl = '';
      let receiptFileName = '';
      if (data.receiptFile) {
        const path = `receipts/${branchId}/${Date.now()}_${data.receiptFile.name}`;
        const { data: uploadData, error: uploadError } = await supabase.storage.from('receipts').upload(path, data.receiptFile);
        if (uploadError) throw uploadError;
        const { data: urlData } = supabase.storage.from('receipts').getPublicUrl(uploadData.path);
        receiptUrl = urlData.publicUrl;
        receiptFileName = data.receiptFile.name;
      }

      const id = crypto.randomUUID();
      const payload = {
        id,
        expense_date: data.date instanceof Date ? data.date.toISOString() : data.date,
        amount: data.amount,
        category: data.category,
        sub_category: data.subCategory,
        description: data.description,
        supplier: data.supplier,
        quantity: data.quantity || 1,
        unit_price: data.unitPrice || 0,
        branch_id: branchId,
        branch_name: branchName,
        payment_method: data.paymentMethod,
        receipt_url: receiptUrl,
        receipt_file_name: receiptFileName,
        inventory_updates: data.inventoryUpdates || [],
        related_request_id: data.relatedRequestId,
        related_order_id: data.relatedOrderId,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const { error } = await supabase.from('simple_expenses').insert([payload]);
      if (error) throw error;

      // Sync Partner
      if (data.supplier) {
        const { data: partner } = await supabase.from('partners').select('*').eq('name', data.supplier).maybeSingle();
        if (!partner) {
          await supabase.from('partners').insert([{
            id: crypto.randomUUID(), name: data.supplier, type: '기타공급업체', branch: branchName, memo: `간편지출 자동 추가`, created_at: new Date().toISOString()
          }]);
        }
      }

      // Sync Material
      if (data.category === SimpleExpenseCategory.MATERIAL && data.description) {
        const { data: mat } = await supabase.from('materials').select('*').eq('name', data.description).eq('branch', branchName).maybeSingle();
        if (!mat) {
          await supabase.from('materials').insert([{
            id: `MAT${Date.now()}`, name: data.description, main_category: '기타자재', mid_category: '기타', price: data.unitPrice || 0, supplier: data.supplier || '미지정', stock: data.quantity || 1, branch: branchName, created_at: new Date().toISOString()
          }]);
        } else {
          await supabase.from('materials').update({ stock: (mat.stock || 0) + (data.quantity || 1), price: data.unitPrice || mat.price }).eq('id', mat.id);
        }
      }

      // Sync Stock
      if (data.inventoryUpdates?.length) {
        for (const item of data.inventoryUpdates) {
          if (item.type === 'material') await updateMaterialStock([{ id: item.id, name: item.name, quantity: item.quantity, price: item.unitPrice }], 'in', branchName, user.email || 'system');
          else if (item.type === 'product') await updateProductStock([{ id: item.id, name: item.name, quantity: item.quantity, price: item.unitPrice }], 'in', branchName, user.email || 'system');
        }
      }

      // Sync Material Request
      if (data.relatedRequestId) {
        await supabase.from('material_requests').update({ status: 'completed', updated_at: new Date().toISOString() }).eq('id', data.relatedRequestId);
      }

      // Sync Supplier Suggestions
      if (data.supplier) {
        const { data: sugg } = await supabase.from('supplier_suggestions').select('*').eq('name', data.supplier).maybeSingle();
        if (!sugg) await supabase.from('supplier_suggestions').insert([{ id: crypto.randomUUID(), name: data.supplier, category: data.category, frequency: 1, last_used: new Date().toISOString() }]);
        else await supabase.from('supplier_suggestions').update({ frequency: (sugg.frequency || 0) + 1, last_used: new Date().toISOString() }).eq('id', sugg.id);
      }

      toast({ title: "등록 완료", description: "지출이 등록되었습니다." });
      await fetchExpenses();
      return true;
    } catch (error) {
      console.error(error);
      toast({ variant: "destructive", title: "오류", description: "지출 등록 실패" });
      return false;
    } finally {
      setLoading(false);
    }
  }, [user, toast, updateMaterialStock, updateProductStock, fetchExpenses]);

  const updateExpense = useCallback(async (expenseId: string, data: Partial<CreateSimpleExpenseData>): Promise<boolean> => {
    if (!user) return false;
    setLoading(true);
    try {
      const updatePayload: any = { updated_at: new Date().toISOString() };
      if (data.receiptFile) {
        const { data: exp } = await supabase.from('simple_expenses').select('branch_id').eq('id', expenseId).single();
        if (exp) {
          const path = `receipts/${exp.branch_id}/${Date.now()}_${data.receiptFile.name}`;
          const { data: up } = await supabase.storage.from('receipts').upload(path, data.receiptFile);
          if (up) {
            const { data: url } = supabase.storage.from('receipts').getPublicUrl(up.path);
            updatePayload.receipt_url = url.publicUrl;
            updatePayload.receipt_file_name = data.receiptFile.name;
          }
        }
      }
      if (data.amount) updatePayload.amount = data.amount;
      if (data.description) updatePayload.description = data.description;
      if (data.date) updatePayload.expense_date = data.date instanceof Date ? data.date.toISOString() : data.date;

      const { error } = await supabase.from('simple_expenses').update(updatePayload).eq('id', expenseId);
      if (error) throw error;
      toast({ title: "수정 완료", description: "지출 정보가 수정되었습니다." });
      await fetchExpenses();
      return true;
    } catch (error) {
      console.error(error);
      return false;
    } finally {
      setLoading(false);
    }
  }, [user, fetchExpenses]);

  const deleteExpense = useCallback(async (expenseId: string): Promise<boolean> => {
    if (!user) return false;
    try {
      const { error } = await supabase.from('simple_expenses').delete().eq('id', expenseId);
      if (error) throw error;
      toast({ title: "삭제 완료", description: "성공했습니다." });
      await fetchExpenses();
      return true;
    } catch (error) {
      console.error(error);
      return false;
    }
  }, [user, fetchExpenses]);

  const fetchSupplierSuggestions = useCallback(async (searchTerm: string = '') => {
    try {
      let query = supabase.from('supplier_suggestions').select('*').order('frequency', { ascending: false }).limit(10);
      if (searchTerm) query = query.ilike('name', `%${searchTerm}%`);
      const { data } = await query;
      setSupplierSuggestions((data || []).map(s => ({ id: s.id, name: s.name, category: s.category, frequency: s.frequency, lastUsed: s.last_used })));
    } catch (error) { console.error(error); }
  }, []);

  const fetchFixedCostTemplate = useCallback(async (branchId: string): Promise<FixedCostTemplate | null> => {
    try {
      const { data } = await supabase.from('fixed_cost_templates').select('*').eq('branch_id', branchId).maybeSingle();
      if (!data) return null;
      return { id: data.id, branchId: data.branch_id, branchName: data.branch_name, items: data.items, createdAt: data.created_at, updatedAt: data.updated_at };
    } catch (error) { return null; }
  }, []);

  const saveFixedCostTemplate = useCallback(async (branchId: string, branchName: string, items: any[]): Promise<boolean> => {
    if (!user) return false;
    try {
      const existing = await fetchFixedCostTemplate(branchId);
      const payload = { branch_id: branchId, branch_name: branchName, items, updated_at: new Date().toISOString() };
      if (existing) await supabase.from('fixed_cost_templates').update(payload).eq('id', existing.id);
      else await supabase.from('fixed_cost_templates').insert([{ ...payload, id: crypto.randomUUID(), created_at: new Date().toISOString() }]);
      toast({ title: "저장 완료", description: "템플릿이 저장되었습니다." });
      return true;
    } catch (error) { return false; }
  }, [user, fetchFixedCostTemplate]);

  const addFixedCosts = useCallback(async (branchId: string, branchName: string, items: any[], date: Date): Promise<boolean> => {
    if (!user) return false;
    setLoading(true);
    try {
      const activeItems = items.filter(item => item.isActive && item.amount > 0);
      const payloads = activeItems.map(item => ({
        id: crypto.randomUUID(),
        expense_date: date.toISOString(),
        amount: item.amount,
        category: item.category,
        sub_category: item.subCategory,
        description: item.name,
        supplier: item.supplier,
        branch_id: branchId,
        branch_name: branchName,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }));
      const { error } = await supabase.from('simple_expenses').insert(payloads);
      if (error) throw error;
      toast({ title: "일괄 입력 완료", description: `${payloads.length}개 지출 등록됨` });
      await fetchExpenses();
      return true;
    } catch (error) { return false; } finally { setLoading(false); }
  }, [user, fetchExpenses]);

  const calculateStats = useCallback((expenseList: SimpleExpense[]): ExpenseStats => {
    const totalAmount = expenseList.reduce((sum, expense) => sum + expense.amount, 0);
    const categoryMap = new Map();
    expenseList.forEach(expense => {
      const existing = categoryMap.get(expense.category) || { amount: 0, count: 0 };
      categoryMap.set(expense.category, { amount: existing.amount + expense.amount, count: existing.count + 1 });
    });
    const categoryBreakdown = Array.from(categoryMap.entries()).map(([category, data]) => ({ category, amount: data.amount, count: data.count, percentage: totalAmount > 0 ? (data.amount / totalAmount) * 100 : 0 }));

    const monthlyMap = new Map();
    expenseList.forEach(expense => {
      const monthKey = new Date(expense.date).toISOString().slice(0, 7);
      monthlyMap.set(monthKey, (monthlyMap.get(monthKey) || 0) + expense.amount);
    });
    const monthlyTrend = Array.from(monthlyMap.entries()).sort(([a], [b]) => a.localeCompare(b)).slice(-6).map(([month, amount]) => ({ month, amount }));

    const supplierMap = new Map();
    expenseList.forEach(expense => {
      const existing = supplierMap.get(expense.supplier) || { amount: 0, count: 0 };
      supplierMap.set(expense.supplier, { amount: existing.amount + expense.amount, count: existing.count + 1 });
    });
    const topSuppliers = Array.from(supplierMap.entries()).map(([name, data]) => ({ name, amount: data.amount, count: data.count })).sort((a, b) => b.amount - a.amount).slice(0, 10);

    return { totalAmount, categoryBreakdown, monthlyTrend, topSuppliers };
  }, []);

  const addMaterialRequestExpense = useCallback(async (materialRequest: MaterialRequest, actualPurchaseInfo: any): Promise<boolean> => {
    if (!actualPurchaseInfo || !materialRequest.branchId) return false;
    try {
      const payload = {
        id: crypto.randomUUID(),
        expense_date: actualPurchaseInfo.purchaseDate,
        amount: actualPurchaseInfo.totalCost,
        category: SimpleExpenseCategory.MATERIAL,
        sub_category: 'material_request',
        description: `자재요청 구매 (${materialRequest.requestNumber})`,
        supplier: actualPurchaseInfo.items[0]?.supplier || '자재구매',
        branch_id: materialRequest.branchId,
        branch_name: materialRequest.branchName,
        related_request_id: materialRequest.id,
        is_auto_generated: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      await supabase.from('simple_expenses').insert([payload]);
      toast({ title: '성공', description: `자동 등록되었습니다.` });
      return true;
    } catch (error) { return false; }
  }, [toast]);

  useEffect(() => {
    if (user) { fetchExpenses(); fetchSupplierSuggestions(); }
  }, [user, fetchExpenses, fetchSupplierSuggestions]);

  return {
    expenses, loading, supplierSuggestions,
    fetchExpenses, addExpense, updateExpense, deleteExpense, fetchSupplierSuggestions, fetchFixedCostTemplate, saveFixedCostTemplate, addFixedCosts, calculateStats, addMaterialRequestExpense
  };
}
